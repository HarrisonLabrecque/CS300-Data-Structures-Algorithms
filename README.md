# CS300-Data-Structures-Algorithms

What was the problem you were solving in the projects for this course?

The primary objective of the course projects was to explore and implement efficient data structures and algorithms. In Project One, the challenge involved analyzing the time and space complexities of various data structures, including arrays, linked lists, stacks, queues, and hash tables. The goal was to evaluate the performance characteristics of these data structures in relation to their efficiency when performing different operations. In Project Two, the task was to write code to sort and display a list of courses in alphanumeric order by applying different sorting algorithms and understanding how to manipulate data structures to achieve the desired outcome.

How did you approach the problem? Consider why data structures are essential to understand.

In addressing these challenges, I initially concentrated on understanding the theoretical aspects of data structures, including their use cases, time complexity for everyday operations (such as insertions, deletions, and lookups), and their memory consumption. For Project One, I reviewed big-O notation to categorize each operation and gained insight into how the efficiency of a data structure can vary based on the specific problem. In Project Two, I chose a sorting algorithm that suited the task—such as quicksort or merge sort—ensuring it would sort the list of courses efficiently. Data structures are essential because they determine how effectively we can store and manipulate data. Knowing which data structure to apply for a given task can significantly influence the performance and scalability of the program.

How did you overcome any roadblocks you encountered while going through the activities or project?

One of the main challenges I faced was analyzing the performance of various data structures. Initially, I struggled to determine when to use specific data structures, especially in more complex scenarios, such as choosing between a linked list and an array. To address this issue, I broke down the problem into smaller parts, reviewed the time and space complexities, and examined practical examples of the appropriate use of each data structure.

For Project Two, the initial challenge involved sorting the courses by different methods while also considering edge cases, such as duplicate courses. I tackled this by dividing the problem into smaller tasks: first sorting the courses and then addressing any edge cases that arose.

How has your work on this project expanded your approach to designing software and developing programs?

This project has changed my approach to software design by highlighting the importance of selecting the proper data structure for each specific task. I have come to realize that performance optimization begins with effective data management. Now, when designing software, I carefully consider how my choice of data structures will affect overall performance, particularly as data scales increase. Additionally, this experience has prompted me to think more critically about algorithm efficiency and how to tailor algorithms to meet the specific needs of the software, especially when working with large datasets.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

My work on this project has increased my awareness of the importance of writing clean, well-structured code that is not only functional but also optimized for future modifications. I’ve learned to use clear variable names, provide meaningful comments, and apply proper function decomposition to enhance code readability. Additionally, I now prioritize modularity by structuring my code in a way that allows for easy updates or changes, especially when new data structures or algorithms are introduced. By adopting these practices, I feel confident that my code is more maintainable and can be easily modified or expanded to meet new requirements as they arise.
